name: Build and Release Electron App

on:
  push:
    branches:
      - main
  release:
    types: [published]

permissions:
  contents: write
  pages: write
  id-token: write

env:
  NODE_VERSION: '20'

jobs:
  # 跨平台构建 - 推送到main或创建release时都运行
  build:
    runs-on: ${{ matrix.os }}
    timeout-minutes: 90
    strategy:
      matrix:
        include:
          - os: macos-latest
            platform: mac
            artifact-name: 'macos-build'
            icon-ext: 'icns'
          - os: windows-latest
            platform: win
            artifact-name: 'windows-build'
            icon-ext: 'ico'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install all dependencies (including dev)
        timeout-minutes: 15
        run: |
          echo "安装完整依赖用于构建..."
          npm ci --prefer-offline --no-audit --progress=false
        env:
          npm_config_cache: .npm
          npm_config_prefer-offline: true
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
          PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: true

      - name: Build renderer process with optimizations
        timeout-minutes: 30
        run: |
          echo "开始Vite构建（启用优化）..."
          npm run build:vite
        env:
          NODE_ENV: production
          CI: true
          # Vite优化选项
          VITE_BUILD_MINIFY: true
          VITE_BUILD_CHUNK_SIZE_WARNING_LIMIT: 2000

      - name: Build main process
        run: npm run build:electron
        env:
          NODE_ENV: production
          CI: true

      - name: Create production node_modules
        timeout-minutes: 10
        run: |
          echo "创建纯净的生产依赖目录..."
          mkdir -p temp_prod
          # 复制必要的配置文件到临时目录
          cp package.json temp_prod/
          cp package-lock.json temp_prod/
          # 在临时目录中安装生产依赖
          cd temp_prod
          npm ci --omit=dev --prefer-offline --no-audit --progress=false
          cd ..
          # 复制生产依赖到最终目录
          mkdir -p temp_node_modules
          cp -r temp_prod/node_modules temp_node_modules/
          rm -rf temp_prod
        env:
          npm_config_cache: .npm
          npm_config_prefer-offline: true
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
          PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: true

      - name: Replace node_modules (Unix)
        if: runner.os != 'Windows'
        run: |
          echo "替换为生产依赖..."
          rm -rf node_modules
          mv temp_node_modules/node_modules ./

      - name: Replace node_modules (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "替换为生产依赖..."
          if (Test-Path "node_modules") { Remove-Item -Recurse -Force "node_modules" }
          Move-Item "temp_node_modules/node_modules" "./"

      - name: Optimize build for packaging
        run: npm run optimize:build
        env:
          NODE_ENV: production

      - name: Verify build output (Unix)
        if: runner.os != 'Windows'
        run: |
          echo "=== Build directory contents ==="
          ls -la build/ || echo "Build directory not found"
          echo "=== Dist directory contents ==="  
          ls -la dist/ || echo "Dist directory not found"
          echo "=== Icon files ==="
          ls -la electron/icon.${{ matrix.icon-ext }} || echo "Icon file not found"
          echo "=== Node modules size ==="
          du -sh node_modules/ || echo "Node modules not found"

      - name: Verify build output (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "=== Build directory contents ==="
          if (Test-Path "build") { Get-ChildItem -Path "build" -Force } else { Write-Host "Build directory not found" }
          Write-Host "=== Dist directory contents ==="  
          if (Test-Path "dist") { Get-ChildItem -Path "dist" -Force } else { Write-Host "Dist directory not found" }
          Write-Host "=== Icon files ==="
          if (Test-Path "electron/icon.${{ matrix.icon-ext }}") { Get-ChildItem -Path "electron/icon.${{ matrix.icon-ext }}" -Force } else { Write-Host "Icon file not found" }
          Write-Host "=== Node modules size ==="
          if (Test-Path "node_modules") { [math]::Round((Get-ChildItem -Recurse node_modules | Measure-Object -Property Length -Sum).Sum / 1MB, 2).ToString() + " MB" } else { Write-Host "Node modules not found" }

      - name: Build Electron app for macOS
        if: matrix.platform == 'mac'
        timeout-minutes: 45
        run: npx electron-builder --mac --publish never
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: false
          DEBUG: electron-builder
          # 禁用macOS公证以避免签名问题
          CSC_LINK: ""
          CSC_KEY_PASSWORD: ""
          CSC_NAME: ""
          APPLEID: ""
          APPLEIDPASS: ""
          ASC_PROVIDER: ""
          # 完全跳过代码签名
          SKIP_NOTARIZATION: true

      - name: Build Electron app for Windows  
        if: matrix.platform == 'win'
        timeout-minutes: 60
        run: |
          # 清除所有可能的代码签名环境变量
          echo "清除代码签名环境变量..."
          set CSC_LINK=
          set WIN_CSC_LINK=
          set CSC_KEY_PASSWORD=
          set WIN_CSC_KEY_PASSWORD=
          set CSC_NAME=
          set WIN_CSC_NAME=
          set CSC_IDENTITY_AUTO_DISCOVERY=false
          set CSC_FOR_PULL_REQUEST=true
          set DEBUG=electron-builder
          
          echo "开始构建Windows应用（仅64位，无压缩模式）..."
          npx electron-builder --win --x64 --publish never
        shell: cmd
        env:
          # 明确禁用所有代码签名相关环境变量
          CSC_LINK: ""
          WIN_CSC_LINK: ""
          CSC_KEY_PASSWORD: ""
          CSC_IDENTITY_AUTO_DISCOVERY: "false"
          # 添加更多禁用选项
          WIN_CSC_KEY_PASSWORD: ""
          CSC_NAME: ""
          WIN_CSC_NAME: ""
          # 调试信息
          DEBUG: "electron-builder"
          # 确保不使用任何证书存储
          CSC_FOR_PULL_REQUEST: "true"

      - name: List build artifacts (Unix)
        if: runner.os != 'Windows'
        run: |
          echo "=== Release directory contents ==="
          ls -la release/ || echo "Release directory not found"
          echo "=== Build artifacts ==="
          find release/ -type f \( -name "*.dmg" -o -name "*.exe" -o -name "*.zip" -o -name "*.AppImage" \) -exec ls -lh {} \; || echo "No build artifacts found"

      - name: List build artifacts (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "=== Release directory contents ==="
          if (Test-Path "release") { Get-ChildItem -Path "release" -Force } else { Write-Host "Release directory not found" }
          Write-Host "=== Build artifacts ==="
          if (Test-Path "release") { 
            Get-ChildItem -Path "release" -Recurse -File | Where-Object { $_.Extension -in @('.dmg', '.exe', '.zip', '.AppImage') } | ForEach-Object { "{0:N2} MB  {1}" -f ($_.Length / 1MB), $_.FullName }
          } else { 
            Write-Host "No build artifacts found" 
          }

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: release/
          retention-days: 30
          if-no-files-found: error

  # 自动发布 - 仅在推送到main时运行（创建预发布版本）
  auto-release:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download macOS Artifacts
        uses: actions/download-artifact@v4
        with:
          name: macos-build
          path: dist-artifacts/mac

      - name: Download Windows Artifacts  
        uses: actions/download-artifact@v4
        with:
          name: windows-build
          path: dist-artifacts/win

      - name: List all artifacts
        run: |
          echo "=== Downloaded artifacts ==="
          find dist-artifacts/ -type f -exec ls -lh {} \;

      - name: Get package version
        id: package-version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION-$(date +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT

      - name: Create Auto Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.package-version.outputs.tag }}
          name: "Auto Build v${{ steps.package-version.outputs.version }} - $(date '+%Y-%m-%d %H:%M:%S')"
          body: |
            🤖 **自动构建版本**
            
            📅 构建时间: $(date '+%Y-%m-%d %H:%M:%S')
            📝 提交: ${{ github.sha }}
            🔗 分支: ${{ github.ref_name }}
            
            ## 下载链接
            - 🍎 **macOS**: 下载 `.dmg` 文件
            - 🪟 **Windows**: 下载 `.exe` 文件
            
            > ⚠️ 这是自动构建版本，可能包含未完全测试的功能。
          files: |
            dist-artifacts/**/*.dmg
            dist-artifacts/**/*.exe
            dist-artifacts/**/*.zip
            dist-artifacts/**/*.blockmap
          prerelease: true
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # 正式发布 - 仅在手动创建release时运行
  official-release:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    steps:
      - name: Download macOS Artifacts
        uses: actions/download-artifact@v4
        with:
          name: macos-build
          path: dist-artifacts/mac

      - name: Download Windows Artifacts  
        uses: actions/download-artifact@v4
        with:
          name: windows-build
          path: dist-artifacts/win

      - name: List all artifacts
        run: |
          echo "=== Downloaded artifacts for official release ==="
          find dist-artifacts/ -type f -exec ls -lh {} \;

      - name: Attach to Official Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            dist-artifacts/**/*.dmg
            dist-artifacts/**/*.exe
            dist-artifacts/**/*.zip
            dist-artifacts/**/*.blockmap
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
